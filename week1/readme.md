# week1

二分 和 基础排序，
将位运算（神仙题）移到 week14


https://www.nowcoder.com/study/live/348/1/5

时间复杂度，空间复杂度

## 基础排序 

选择排序，冒泡排序，插入排序

(如无特殊说明，有序指的都是升序)

先判断数组是否为空，以及长度是否大于0

**选择排序**

i: 0...n-1

遍历 i...n-1 找到 minIdx

交换 minIdx 和 i

**冒泡排序**

01 12 23 ... n-2 n-1 两两比较，> 的话，swap
01 12 23 ... n-2 n-3 两两比较...

**插入排序**

最有技巧的

i: 0...n-1

// 看 0..0 是否有序
// 看 0..1 是否有序
// 看 0..2 是否有序
// 看 0..3 是否有序
// 看 0..i 是否有序

判断有序的方法

比较 i-1 和 i，如果 >，一直交换到 i 到(目前)应该在的位置
```java
for(int j = i; j >= 1 && arr[j-1] > arr[j]; j--) {
    swap(arr, j-1, j)
}
```

因为 0...i-1 都是有序的，可能 arr[i] > arr[i-1]， 比较一次就结束了

为什么插入排序优于选择排序和冒泡排序：

选择排序和冒泡排序的时间复杂度与数据状况无关，

而插入排序不同，如果原始数据是有序的，并不会跑的第二个循环(只是摸一下第二个循环的判断条件)

最好时间复杂度 O(n)

## 二分法

**变体问题**

https://www.nowcoder.com/study/live/348/1/6
6:30

111111 2222 333333 444444
       |
       
求 刚好 <= 2 的位置

二分到没有数字，用一个全局变量记录成功的数字

https://www.nowcoder.com/study/live/348/1/6
14:30

**求任意的局部最小值**

162. Find Peak Element
https://leetcode.com/problems/find-peak-element/
和老师讲的正好相反，局部最大值

局部最小的定义

[0] < [1]
[n-1] < [n-2]

[i-1] > [i] < [i+1]

arr 无序，且无重复的数字

先比较 [0] <? [1], [n-1] <? [n-2]
如果为真，则返回
如果不为真，那么中间一定存在拐点

 \            /
0  1 ...   n-2 n-1
既然头尾有上升，有下降，那么中间必然有拐点

然后到中间找

 \         \/         /
0  1   m-1 m m+1   n-2 n-1

这个样子，返回 m

 \        /           /
0  1   m-1 m m+1   n-2 n-1

这个样子，到 1 和 m-1 中间找

 \          \         /
0  1   m-1 m m+1   n-2 n-1
同理


## 异或的性质

1. 0^n = n n^n = 0
2. 异或操作满足交换率，结合率
3. 不用额外变量，交换两个数字
4. 数组中，一种数出现了奇数次，其他数都出现了偶数次，求这个数
136. Single Number

5. 数组中，两种数出现了奇数次，其他数都出现了偶数次，求这个两数
260. Single Number III
如何记：无进位相加

提取最右的1

010010101000
->
000000001000

n&(~n+1) // 直接记就可以了

## 递归复杂度计算公式 master 

T(N) = aT(N/b) + O(N^d)

b: 每一次调用，规模缩小 b
a: 调用 a 次

如

```python
def process(nums, l, r):
    if len(nums) == 0:
        return
    m = (l + r) // 2
    process(nums, l, m)
    process(nums, m+1, r)

# T(N) = 2T(N/b) + O(1)
# 调用自身2次
# 每次调用，数据规模变为 1/2
```
